# 스레드 안정성
> 스레드 안정성이란?
>
> 여러 스레드가 특정 클래스에 접근할 때, 실행 환경의 스케줄링의 종류에 상관없이 호출하는 쪽에서
> 추가적인 동기화나 다른 조율 없이도 정확하게 동작하는 경우 스레드 안정성 혹은 'Thread-safe' 하다고 한다.

## Thread-safe point


- 'stateless' 한 객체는 다른 스레드에서 접근할 여지가 없다.


- 경쟁 조건을 피하느 법은 특정 변수가 수정되는 동안 다른 스레드가 해당 변수를 사용하지 못하도록 하는 것이다.
- 하나의 스레드가 변수에 접근하여 단일 연산을 보장하는 것을, 이걸 'lock' 이라고 부른다.
- 가능하면 클래스 상태를 관리하기 위해 AtomicLong 과 같이 이미 만들어진 thread-safe 한 객체를 사용하는 것이 좋다.
- 상태를 일관성 있게 유지하려면 관련 있는 변수들을 하나의 단일 연산으로 갱신해야 한다.
- Java 의 객체 안에는 락이 내재되어 있는데, 암묵적인 락(intrinsic lock) 혹은 모니터 락(monitor lock)이라고 한다.
- 암묵적인 락은 재진입이 가능하기 때문에 특정 스레드가 자기가 이미 획득한 락을 다시 확보할 수 있다.
- 여러 스레드에서 접근할 수 있고 변경 가능한 모든 변수를 대상으로 해당 변수에 접근할 때는 항상 동일한 락을 먼저 확보한 상태여야 한다. 이 경우 해당 변수는 확보된 락에 의해 보호된다고 말한다.
- 모든 변경할 수 있는 공유 변수는 정확하게 단 하나의 락으로 보호해야 한다. 
- 유지 보수하는 사람이 알 수 있게 어느 락으로 보호하고 있는지를 명확하게 표시하라.

## Not Thread-safe point


- 그러나 thread-safe 한 객체를 사용하더라도, 동기화를 하지 않은채, 교차 연산 작업을 할 경우, 스레드 안전성이 깨진다.


- 동기화를 하지 않고, 상태변수를 선언한 다음 그 상태변수에 단일 연산을 하는 객체의 경우 절대 thread-safe 할 수 없다.


- 늦은 초기화(lazy-initialization)가 목적인 싱글톤 패턴의 경우, 동기화를 진행하지 않을 경우 스레드 안정성이 깨질 수 있다.
- 너무 일괄적으로 락을 걸 경우, 스레드 안정성은 확보하지만, 성능이 크게 저하될 수 있다.
- 따라서, 락을 걸 때는 정말 필요한 부분만 쪼개서 락을 걸어야 하지만, 락을 걸고 풀어놓는 작업만으로도 어느정도 부하가 따르기 때문에 락을 너무 쪼개는 것은 바람직하지 못하다.
- 종종 단순성과 성능이 서로 상충할 때가 있다. 성능을 위해 조급하게 단순성을 희생하고 싶은 유혹을 버려라
- 복잡하고 오래 걸리는 계산 작업, 네트워크, 사용자 입출력 작업과 같이 빨리 끝나지 않을 수 있는 작업을 하는 부분에서는 가능한 락을 잡지 말아야 한다.

#### 경쟁 조건이란?
여러 스레드가 특정 리소스에 동시에 접근함으로서 연산 결과의 정확성이 달라지는 상황을 이야기 한다.
